# Unit 33. 클로저 사용하기

# 이번에는 변수의 사용 범위와 함수를 클로저 형태로 만드는 방법을 알아보겠습니다.
# 참고로 클로저는 개념이 다소 어려울 수 있으므로
# 변수의 사용 범위부터 알아본 뒤에 설명하겠습니다.


# 33.1 변수의 사용 범위 알아보기 -------------------------------------------------------

x = 10        # 전역 변수
def foo():
    print(x)  # 전역 변수 출력

foo()
print(x)      # 전역 변수 출력

# 함수를 포함하여 스크립트 전체에서 접근할 수 있는 변수를
# 전역 변수(global variable)라고 부릅니다.
# 특히 전역 변수에 접근할 수 있는 범위를 전역 범위(global scope)라고 합니다.


# 그럼 변수 x를 함수 foo 안에서 만들면 어떻게 될까요?
def foo():    # 인터프리터 재실행 후 함수 정의하기. 왜냐면 위에서 전역변수로 x가 설정되었기 때문
    x = 10    # foo의 지역 변수
    print(x)  # foo의 지역 변수 출력

foo()
print(x)  # 에러. foo의 지역 변수는 출력할 수 없음

# 실행을 해보면 x가 정의되지 않았다는 에러가 발생합니다.
# 왜냐하면 변수 x는 함수 foo 안에서 만들었기 때문에 foo의 지역 변수(local variable)입니다.
# 따라서 지역 변수는 변수를 만든 함수 안에서만 접근할 수 있고, 함수 바깥에서는 접근할 수 없습니다.
# 특히 지역 변수를 접근할 수 있는 범위를 지역 범위(local scope)라고 합니다.


# 33.1.1  함수 안에서 전역 변수 변경하기

# 만약 함수 안에서 전역 변수의 값을 변경하면 어떻게 될까요?

x = 10        # 전역 변수
def foo():
    x = 20    # x는 foo의 지역 변수
    print(x)  # foo의 지역 변수 출력

foo()
print(x)      # 전역 변수 출력

# 분명 함수 foo 안에서 x = 20처럼 x의 값을 20으로 변경했습니다.
# 하지만 함수 바깥에서 print로 x의 값을 출력해보면 10이 나옵니다.
# 겉으로 보기에는 foo 안의 x는 전역 변수인 것 같지만 실제로는 foo의 지역 변수입니다. 즉, 전역 변수 x가 있고, foo에서 지역 변수 x를 새로 만들게 됩니다. 이 둘은 이름만 같을 뿐 서로 다른 변수입니다.
#
# 함수 안에서 전역 변수의 값을 변경하려면 global 키워드를 사용해야 합니다.
#
# 다음과 같이 함수 안에서 global에 전역 변수의 이름을 지정해줍니다.
# * global 전역변수

x = 10  # 전역 변수
def foo():
    global x  # 전역 변수 x를 사용하겠다고 설정
    x = 20  # x는 전역 변수
    print(x)  # 전역 변수 출력

foo()
print(x)  # 전역 변수 출력

# 이제 함수 안에서 x를 20으로 변경하면 함수 바깥에서 x를 출력했을 때 20이 나옵니다.
# 이렇게 함수 안에서 변수를 global로 지정하면 전역 변수를 사용하게 됩니다.
# 만약 전역 변수가 없을 때 함수 안에서 global을 사용하면 해당 변수는 전역 변수가 됩니다.


# 33.2 함수 안에서 함수 만들기 -------------------------------------------------------

# 이번에는 함수 안에서 함수를 만드는 방법을 알아보겠습니다.
# 다음과 같이 def로 함수를 만들고 그 안에서 다시 def로 함수를 만들면 됩니다.

# def 함수이름1():
#     코드
#     def 함수이름2():
#         코드


def print_hello():
    hello = 'Hello, world!'
    def print_message():
        print(hello)  # 바깥쪽 함수의 지역변수 활용 가능
    print_message()

print_hello()


# 33.2.1  지역 변수의 범위

# 위 함수에서 안쪽 함수 print_message에서는
# 바깥쪽 함수 print_hello의 지역 변수 hello를 사용할 수 있습니다.




# 33.2.2  지역 변수 변경하기

# 지금까지 바깥쪽 함수의 지역 변수를 안쪽 함수에서 사용해봤습니다.
# 그럼 바깥쪽 함수의 지역 변수를 안쪽 함수에서 변경하면 어떻게 될까요?
# 다음과 같이 안쪽 함수 B에서 바깥쪽 함수 A의 지역 변수 x를 변경해봅니다.

def A():
    x = 10      # A의 지역 변수 x
    def B():
        x = 20  # B의 지역 변수 x를 새로 만듦
    B()
    print(x)    # A의 지역 변수 x 출력

A()

# 실행을 해보면 20이 나와야 할 것 같은데 10이 나왔습니다.
# 왜냐하면 겉으로 보기에는 바깥쪽 함수 A의 지역 변수 x를 변경하는 것 같지만,
# 실제로는 안쪽 함수 B에서 이름이 같은 지역 변수 x를 새로 만들게 됩니다.
# 즉, 파이썬에서는 함수에서 변수를 만들면 항상 현재 함수의 지역 변수가 됩니다.

# 현재 함수의 바깥쪽에 있는 지역 변수의 값을 변경하려면 nonlocal 키워드를 사용해야 합니다.
# 그리고 전역 변수를 바꾸고자 한다면 global 키워드를 이용합니다.

# 하지만 실무에서는 이렇게 여러 단계로 함수를 만들 일은 거의 없습니다.
# 그리고 함수마다 이름이 같은 변수를 사용하기 보다는 변수 이름을 다르게 짓는 것이 좋습니다.

# 파이썬에서 global을 제공하지만 함수에서 값을 주고받을 때는 매개변수와 반환값을 사용하는 것이 좋습니다.
# 특히 전역 변수는 코드가 복잡해졌을 때 변수의 값을 어디서 바꾸는지 알기가 힘듭니다.
# 따라서 전역 변수는 가급적이면 사용하지 않는 것을 권장합니다.




# 33.3 클로저 사용하기 -----------------------------------------------------------------------------------

# 이제 함수를 클로저 형태로 만드는 방법을 알아보겠습니다.
# 다음은 함수 바깥쪽에 있는 지역 변수 a, b를 사용하여 a * x + b를 계산하는
# 함수 mul_add를 만든 뒤에 함수 mul_add 자체를 반환합니다.

def calc():
    a = 3
    b = 5
    def mul_add(x):
        return a * x + b    # 함수 바깥쪽에 있는 지역 변수 a, b를 사용하여 계산
    return mul_add          # mul_add 함수를 반환


# 다음과 같이 함수 calc를 호출한 뒤 반환값을 c에 저장합니다.
# calc에서 mul_add를 반환했으므로 c에는 함수 mul_add가 들어갑니다.
# 그리고 c에 숫자를 넣어서 호출해보면 a * x + b 계산식에 따라 값이 출력됩니다.

c = calc()
print(c(1), c(2), c(3), c(4), c(5))

# 잘 보면 함수 calc가 끝났는데도 c는
# calc의 지역 변수 a, b를 사용해서 계산을 하고 있습니다.
# 이렇게 함수를 둘러싼 환경(지역 변수, 코드 등)을 계속 유지하다가,
# 함수를 호출할 때 다시 꺼내서 사용하는 함수를 클로저(closure)라고 합니다.
# 여기서는 c에 저장된 함수가 클로저입니다.


# 이처럼 클로저를 사용하면 프로그램의 흐름을 변수에 저장할 수 있습니다.
# 즉, 클로저는 지역 변수와 코드를 묶어서 사용하고 싶을 때 활용합니다.
# 또한, 클로저에 속한 지역 변수는 바깥에서 직접 접근할 수 없으므로 데이터를 숨기고 싶을 때 활용합니다.


# 33.3.1  lambda로 클로저 만들기

def calc():
    a = 3
    b = 5
    return lambda x: a * x + b  # 람다 표현식을 반환

c = calc()
print(c(1), c(2), c(3), c(4), c(5))



# 33.3.2  클로저의 지역 변수 변경하기

# 지금까지 클로저의 지역 변수를 가져오기만 했는데,
# 클로저의 지역 변수를 변경하고 싶다면 nonlocal을 사용하면 됩니다.

# 다음은 a * x + b의 결과를 함수 calc의 지역 변수 total에 누적합니다.

def calc():
    a = 3
    b = 5
    total = 0

    def mul_add(x):
        nonlocal total
        total = total + a * x + b
        print(total)

    return mul_add

c = calc()
c(1)
c(2)
c(3)


# 33.5 연습문제 : 호출 횟수를 세는 함수 만들기

def counter():
    i = 0
    def count():
        nonlocal i
        i += 1
        return i
    return count

c = counter()
for i in range(10):
    print(c(), end=' ')



# 33.6 심사문제 : 카운트다운 함수 만들기

# 표준 입력으로 정수가 입력됩니다.
# 다음 소스 코드를 완성하여 함수 c를 호출할 때마다 숫자가 1씩 줄어들게 만드세요.
# 여기서는 함수를 클로저로 만들어야 합니다.
# 정답에 코드를 작성할 때는 def countdown(n):에 맞춰서 들여쓰기를 해주세요.

# 답안 1
def countdown(n):
    def count():
        nonlocal n
        n -= 1
        return n + 1
    return count

# 답안 2
def countdown2(n):
    i = n + 1
    def count2():
        nonlocal i
        i -= 1
        return i
    return count2

n = int(input())

c = countdown(n)
for i in range(n):
    print(c(), end=' ')

# c2 = countdown2(n)
# for i in range(n):
#     print(c2(), end=' ')