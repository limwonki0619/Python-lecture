# Unit 35. 클래스 속성과 정적, 클래스 메서드 사용하기

# 지금까지 간단하게 클래스를 만들고 속성과 메서드를 사용해봤습니다.
# 이번에는 클래스에 속해 있는 클래스 속성에 대해 알아보겠습니다.
# 그리고 인스턴스를 만들지 않고 클래스로 호출하는 정적 메서드와 클래스 메서드도 사용해보겠습니다.


# 35.1 클래스 속성과 인스턴스 속성 알아보기 ----------------------------------------------

# '34.2 속성 사용하기'에서 클래스의 속성을 사용해봤는데,
# 사실 속성에는 클래스 속성과 인스턴스 속성 두 가지 종류가 있습니다.
# __init__ 메서드에서 만들었던 속성은 인스턴스 속성입니다.


# 35.1.1  클래스 속성 사용하기

# 클래스 속성은 다음과 같이 클래스에 바로 속성을 만듭니다

# class 클래스이름:
#     속성 = 값

# 이제 간단하게 사람 클래스에 클래스 속성으로 가방 속성을 넣고 사용해보겠습니다.
# 다음과 같이 Person 클래스에 바로 bag 속성을 넣고, put_bag 메서드를 만듭니다.
# 그리고 인스턴스 두 개를 만든 뒤 각각 put_bag 메서드를 사용합니다.

class Person:
    bag = []

    def put_bag(self, stuff):
        self.bag.append(stuff)

james = Person()
james.put_bag('책')

maria = Person()
maria.put_bag('열쇠')

print(james.bag)
print(maria.bag)

# 가방에 물건을 넣는 간단한 동작을 만들었습니다. 그런데 결과가 좀 이상하죠?
# james와 maria 인스턴스를 만들고 각자 put_bag 메서드로 물건을 넣었는데,
# james.bag과 maria.bag을 출력해보면 넣었던 물건이 합쳐져서 나옵니다.
# 즉, 클래스 속성은 클래스에 속해 있으며 모든 인스턴스에서 공유합니다.

# put_bag 메서드에서 클래스 속성 bag에 접근할 때 self를 사용했습니다.
# 사실 self는 현재 인스턴스를 뜻하므로 클래스 속성을 지칭하기에는 조금 모호합니다.

class Person:
    bag = []

    def put_bag(self, stuff):
        self.bag.append(stuff)

# 그래서 클래스 속성에 접근할 때는 다음과 같이 클래스 이름으로 접근하면 좀 더 코드가 명확해집니다

class Person:
    bag = []

    def put_bag(self, stuff):
        Person.bag.append(stuff)  # 클래스 이름으로 클래스 속성에 접근

# Person.bag이라고 하니 클래스 Person에 속한 bag 속성이라는 것을 바로 알 수 있습니다.
# 마찬가지로 클래스 바깥에서도 다음과 같이 클래스 이름으로 클래스 속성에 접근하면 됩니다.




# 35.1.2  인스턴스 속성 사용하기

# 그럼 가방을 여러 사람이 공유하지 않으려면 어떻게 해야 할까요?
# 그냥 bag을 인스턴스 속성으로 만들면 됩니다.

class Person:
    def __init__(self):
        self.bag = []

    def put_bag(self, stuff):
        self.bag.append(stuff)


james = Person()
james.put_bag('책')

maria = Person()
maria.put_bag('열쇠')

print(james.bag)
print(maria.bag)

# james.bag과 maria.bag을 출력해보면 각자 넣은 물건만 출력됩니다.
# 즉, 인스턴스 속성은 인스턴스별로 독립되어 있으며 서로 영향을 주지 않습니다.

# < 이제 클래스 속성과 인스턴스 속성의 차이점을 정리해보겠습니다. >

# * 클래스 속성   : 모든 인스턴스가 공유. 인스턴스 전체가 사용해야 하는 값을 저장할 때 사용
# * 인스턴스 속성 : 인스턴스별로 독립되어 있음. 각 인스턴스가 값을 따로 저장해야 할 때 사용


# 35.1.3  비공개 클래스 속성 사용하기

# 클래스 속성도 비공개 속성을 만들 수 있습니다.
# 클래스 속성을 만들 때 __속성과 같이 __(밑줄 두 개)로 시작하면 비공개 속성이 됩니다.
# 따라서 클래스 안에서만 접근할 수 있고, 클래스 바깥에서는 접근할 수 없습니다

# class 클래스이름:
#     __속성 = 값    # 비공개 클래스 속성

# 즉, 클래스에서 공개하고 싶지 않은 속성이 있다면 비공개 클래스를 사용해야 합니다.
# 예를 들어 기사 게임 캐릭터는 아이템을 최대 10개까지만 보유할 수 있다고 하죠.

class Knight:
    __item_limit = 10  # 비공개 클래스 속성

    def print_item_limit(self):
        print(Knight.__item_limit)  # 클래스 안에서만 접근할 수 있음

x = Knight()
x.print_item_limit()  # 10

print(Knight.__item_limit)  # 클래스 바깥에서는 접근할 수 없음

# 실행을 해보면 클래스 Knight의 비공개 클래스 속성
# __item_limit는 클래스 안의 print_item_limit 메서드에서만 접근할 수 있고,
# 클래스 바깥에서 접근하면 에러가 발생합니다.
# 아이템의 보유 제한이 10개인데, 이 클래스를 사용하는 사람이 마음대로
# __item_limit = 1000으로 수정하면 곤란하겠죠?

# 이처럼 비공개 클래스 속성은 클래스 바깥으로 드러내고 싶지 않은 값에 사용합니다.





# 35.2 정적 메서드 사용하기 ------------------------------------------------------------

# 지금까지 클래스의 메서드를 사용할 때 인스턴스를 통해서 호출했습니다.
# 이번에는 인스턴스를 통하지 않고 클래스에서 바로 호출할 수 있는
# 정적 메서드와 클래스 메서드에 대해 알아보겠습니다.

# 먼저 정적 메서드입니다.
# 정적 메서드는 다음과 같이 메서드 위에 @staticmethod를 붙입니다.
# 이때 '정적 메서드'는 매개변수에 self를 지정하지 않습니다.

# class 클래스이름:
#     @staticmethod
#     def 메서드(매개변수1, 매개변수2):
#         코드

# @staticmethod처럼 앞에 @이 붙은 것을 데코레이터라고 하며,
# 메서드(함수)에 추가 기능을 구현할 때 사용합니다.
# 데코레이터는 'Unit 42 데코레이터 사용하기'에서 자세히 설명하겠습니다.

class Calc:
    @staticmethod
    def add(a, b):
        print(a + b)

    @staticmethod
    def mul(a, b):
        print(a * b)

# Calc 클래스에서 @staticmethod를 붙여서 add 메서드와 mul 메서드를 만들었습니다.
# 정적 메서드를 호출할 때는 다음과 같이 클래스에서 바로 메서드를 호출하면 됩니다.

Calc.add(10, 20)  # 클래스에서 바로 메서드 호출
Calc.mul(10, 20)  # 클래스에서 바로 메서드 호출



# 정적 메서드는 self를 받지 않으므로 인스턴스 속성에는 접근할 수 없습니다.
# 그래서 보통 정적 메서드는 인스턴스 속성, 인스턴스 메서드가 필요 없을 때 사용합니다.
#
# 여기서 만든 Calc 클래스에 들어있는 add, mul 메서드는
# 숫자 두개를 받아서 더하거나 곱할 뿐 인스턴스의 속성은 필요하지 않습니다.



# 그럼 무엇을 정적 메서드로 만들어야 할까요?
# 정적 메서드는 메서드의 실행이 외부 상태에 영향을 끼치지 않는
# 순수 함수(pure function)를 만들 때 사용합니다.
#
# 순수 함수는 부수 효과(side effect)가 없고
# 입력 값이 같으면 언제나 같은 출력 값을 반환합니다.

# 즉, 정적 메서드는 인스턴스의 상태를 변화시키지 않는 메서드를 만들 때 사용합니다.





